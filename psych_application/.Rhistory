}
}
list( fraction=length(compatible_indexes)/nrow(X), compatible_indexes=compatible_indexes)
}
#' @export
#' @noRd
random_poset <- function(p, graph_density=0.15, trans_reduced = TRUE){
random_posets(nr_pos=1, nr_muts=p , ldenses=graph_density, trans_reduced = trans_reduced)[[1]]
}
random_posets <- function(nr_pos, nr_muts , ldenses, trans_reduced = TRUE){
if(length(ldenses) == 1 ) {
ldenses = rep(ldenses, nr_pos)
} else if(length(ldenses) < nr_pos ) {
stop( paste("Invalid value for ldenses ", ldenses) )
}
if(length(nr_muts) == 1 ) {
nr_muts = rep(nr_muts, nr_pos)
} else if(length(nr_muts) < nr_pos ) {
stop( paste("Invalid value for nr_muts ", nr_edges) )
}
nr_edges = ceiling(choose(nr_muts, 2)*ldenses)
# Initialisation
all_posets = rep(0, nr_pos)
pos = 1
while (pos <= nr_pos){
poset <- matrix(0, nr_muts[pos], nr_muts[pos])
poset[upper.tri(poset)][sample(choose(nr_muts[pos], 2), nr_edges[pos])] <- 1
# added by Hesam. Add the transitive reduced poset to the list
if(trans_reduced) {
poset = trans_reduction(poset)
}
all_posets[pos] = list(poset)
pos = pos + 1
}
all_posets
}
########### transitive closure and reduction of a poset
#' @export
#' @noRd
trans_closure <- function(A) {
old_names = dimnames(A)
colnames(A) =  rownames(A) = paste("n", 1:nrow(A), sep='')
R <- as.relation(A)
RT = transitive_closure(R)
res = relation_incidence(RT)
res = res[rownames(A),colnames(A)]
dimnames(res) = old_names
res
}
#' @export
#' @noRd
trans_reduction <- function(A) {
old_names = dimnames(A)
colnames(A) =  rownames(A) = paste("n", 1:nrow(A), sep='')
R <- as.relation(A)
RT = transitive_reduction(R)
res = relation_incidence(RT)
res = res[rownames(A),colnames(A)]
dimnames(res) = old_names
res
}
############# plotting a cbn
#' @export
#' @noRd
plot_poset <- function(robust_poset, size=12) {
Names = colnames(robust_poset)
colnames(robust_poset) <- Names
rownames(robust_poset) <- Names
am.graph <- new("graphAM", adjMat=robust_poset, edgemode="directed")
plot(am.graph, attrs = list( node = list(color = "transparent", fontsize = size, fontcolor="dodgerblue4"),
edge = list(arrowsize=0.5, color="antiquewhite4")))
}
##########
logsumexp <- function(logs, signs=NULL) {
if(is.null(signs)) {
signs = rep(1, length(logs) )
}
indexes = which(signs != 0)
signs = signs[indexes]
logs = logs[indexes]
m = max(logs)
S = sum(signs*exp(logs-m))
logR = m + log(abs(S))
list(logR=logR, sign=sign(S))
}
myExp <- function(myNum) {
myNum$sign * exp(myNum$logR)
}
convert2EdgeList <- function(poset){
p <- nrow(poset)
edgeList <- list()
if (is.null(rownames(poset))){
for (i in 1:p){
for (j in 1:p){
if (poset[i,j]==1){
edgeList <- c(edgeList, i, j)
}
}
}
} else {
for (i in 1:p){
for (j in 1:p){
if (poset[i,j]==1){
edgeList <- c(edgeList, rownames(poset)[i], rownames(poset)[j])
}
}
}
}
edgeList <- as.vector(unlist(edgeList))
return(edgeList)
}
p = 10
# number of observed genotypes
N = 200
# generate a random poset with p nodes
true_poset = random_poset(p)
?as.relation
??as.relation
library(relations)
p = 10
# number of observed genotypes
N = 200
# generate a random poset with p nodes
true_poset = random_poset(p)
# plot the poset
plot_poset(true_poset)
library(graph)
p = 10
# number of observed genotypes
N = 200
# generate a random poset with p nodes
true_poset = random_poset(p)
# plot the poset
plot_poset(true_poset)
lambda_s = 1
# generate p random mutation rates uniformly distributed between lambda_s/3 to 3lambda_s.
lambdas = runif(p, 1/3*lambda_s, 3*lambda_s)
lambdas
install_github("cbg-ethz/MC-CBN")
library(Rcpp)
install_github("cbg-ethz/MC-CBN")
install_github("cbg-ethz/MC-CBN")
install_github("cbg-ethz/MC-CBN")
install_github("cbg-ethz/MC-CBN")
install_github("cbg-ethz/MC-CBN")
library(devtools)
install_github("cbg-ethz/MC-CBN")
R.Version()
library(devtools)
install_github("cbg-ethz/MC-CBN")
getwd()
library(mvtnorm)
library(BiDAG)
library(Rgraphviz)
library(pcalg)
library(graph)
library(bnlearn)
library(MXM)
library(sbgcop)
library(infotheo)
library(rpcart)
library(devtools)
#source_url("https://raw.githubusercontent.com/cuiruifei/CausalMissingValues/master/R/gaussCItestLocal.R")
source_url("https://raw.githubusercontent.com/cuiruifei/CausalMissingValues/master/R/inferCopulaModel.R")
#source_url("https://raw.githubusercontent.com/cuiruifei/CausalMissingValues/master/R/addMAR.R")
setwd("../R")
# Major file containing the OSEM algorithm
source("ordinalScore.R")
# Modify some of the existing functions in the BiDAG package to accommodate our user-defined functions
insertSource("spacefns.R",package = "BiDAG")
insertSource("usrscorefns.R",package = "BiDAG")
##' rmvDAG2(N, randDAGobj):
##' a function that does the same thing as the pcalg::rmvDAG function
##' but the input DAG is not necessarily topologically ordered
##' @param N: number of samples to be drawn
##' @param randDAGobj: a graph object generated from the pcalg::randDAG function
##' @return a Gaussian dataset
rmvDAG2 <- function(N, randDAGobj) {
AM <- as(randDAGobj, "matrix")
sorted_ind <- ggm::topOrder((AM != 0))
n <- nrow(AM)
data <- matrix(nrow = N,ncol = n)
for (j in sorted_ind) {
parentnodes <- which(AM[,j] != 0)
lp <- length(parentnodes)
switch (as.character(lp),
"0" = {data[,j] <- rnorm(N)},
"1" = {data[,j] <- rnorm(N, mean = data[,parentnodes] * AM[parentnodes,j], sd = 1)},
{data[,j] <- rnorm(N, mean = data[,parentnodes] %*% AM[parentnodes,j], sd = 1)}
)
}
return(data)
}
##' cutfun(L, c):
##' a function that simulates the cell probabilities from a symmetric Dirichlet distribution
##' @param L: number of ordinal levels
##' @param c: Dirichlet concentration parameter
##' @return a list of probabilities of length L, summing up to 1
cutfun <- function(L,c) {
p <- gtools::rdirichlet(1,rep(c,L))
return(qnorm(cumsum(p)[1:(L-1)]))
}
##' convertToOrdinal(scaled_data, exp_levels, concent_param):
##' a function that converts standardized Gaussian data into ordinal data
##' @param scaled_data: Gaussian dataset with each dimension standardized
##' @param exp_levels: expected number of ordinal levels
##' @param concent_param: Dirichlet concentration parameter
##' @return an ordinal dataset
convertToOrdinal <- function(scaled_data, exp_levels = 4,concent_param = 2) {
n <- ncol(scaled_data)
if (exp_levels == 2) {
ordinal_levels <- replicate(n,2)
} else {
ordinal_levels <- replicate(n,sample(c(2:(2 * exp_levels - 2)),1))
}
ordinal_data <- scaled_data
for (i in c(1:n)) {
check_levels <- ordinal_levels[i] - 1
while (check_levels != ordinal_levels[i]) {
cuts <- c(-Inf,
cutfun(ordinal_levels[i],concent_param),
Inf)
temp <- cut(scaled_data[,i], simplify2array(cuts), labels = FALSE) - 1
check_levels <- length(unique(temp))
}
ordinal_data[,i] <- temp
}
colnames(ordinal_data) <- c(1:n)
return(ordinal_data)
}
##' mywFUN(m):
##' a function that samples the edge weights uniformly from the interval (-1,-0.4) U (0.4,1)
##' @param m: number of edges in the DAG
##' @return m edge weights
mywFUN <- function(m) {
return(replicate(m,mywFUNhelper()))
}
mywFUNhelper <- function() {
y <- runif(1, 0, 1.2)
if( y < 0.6 ){
x <- -1 + y
}else{
x <- 0.4 + y - 0.6
}
return(x)
}
set.seed(888)
# Generate a regular DAG with 20 nodes with 4 number of neighbors
n <- 20
trueDAG <- randDAG(n = n, d = 4, method = "er", wFUN = list(mywFUN))
# Generate a Gaussian dataset based on the DAG and standardize each dimension
# Sample size = 500
N <- 500
hidden_data <- rmvDAG2(N, trueDAG)
truecov <- trueCov(trueDAG)
D <- diag(sqrt(diag(truecov)))
D.inv <- chol2inv(chol(D))
trueSigma <- D.inv %*% truecov %*% D.inv
scaled_data <- t(D.inv %*% t(hidden_data))
# Convert the Gaussian dataset into an ordinal dataset
ordinal_data <- convertToOrdinal(scaled_data, exp_levels = 4,concent_param = 2)
ordinal_data_df <- as.data.frame(ordinal_data)
ordinal_data_df[] <- lapply(ordinal_data_df[], as.ordered)
# hybrid method with the BGe score and the Gaussian PC output as the initial search space
BGE <- scoreparameters("bge", ordinal_data, bgepar = list(am = 0.5))
BGEfit <- iterativeMCMC(BGE,scoreout = TRUE)
?iterativeMCMC
BGEfit$score
getwd()
setwd("~/Documents/Projects/OSEM/OSEM/Demo/Demo_cache/markdown_github/")
ls
load("OSEM_30d3dc60df2aefddbf20f03d09c05209.RData")
load("OSEM_30d3dc60df2aefddbf20f03d09c05209.RData")
OSEMfit <- readRDS("OSEM_30d3dc60df2aefddbf20f03d09c05209.RData")
load("OSEM_30d3dc60df2aefddbf20f03d09c05209.RData")
?load
load("OSEM_30d3dc60df2aefddbf20f03d09c05209.RData",verbose = TRUE)
?pmvnorm
?boot.strength
library(BiDAG)
library(pcalg)
library(bnlearn)
# Load data
load("OCDRogers.RData")
n <- ncol(datRogers)
N <- nrow(datRogers)
setwd("~/Documents/Projects/OSEM/OSEM/pysch_application/")
# Load data
load("OCDRogers.RData")
n <- ncol(datRogers)
N <- nrow(datRogers)
test <- sample(1:N, N/5, replace=FALSE)
train <- (-test)
train.data <- datRogers[train,]
test.data <- datRogers[test,]
dim(train.data)
dim(test.data)
source('~/Documents/Projects/OSEM/OSEM/R/ordinalScore.R', echo=TRUE)
# OSEM
OSEMfit <- ordinalStructEM(n, train.data,
usrpar = list(penType = "other",
L = 5,
lambda = 6))
test.param <- OSEMfit$param
test.param$data <- test.data
observedLL(test.param)
test.param$Sigma_hat
# BGe
BGE <- scoreparameters("bge", datRogers,bgepar = list(am = 0.05))
?iterativeMCMC
?scoreparameters
BGEfit <- iterativeMCMC(BGE)
?scoreagainstDAG
scoreagainstDAG(BGE, test.data)
observedLL(test.param)
BGE$means
BGE$SigmaN
OSEM.test.param <- OSEMfit$param
OSEM.test.param$data <- test.data
observedLL(OSEM.test.param)
BGE.test.param$Sigma_hat <- cov2cor(BGE$SigmaN)
BGE.test.param <- BGE
BGE.test.param$Sigma_hat <- cov2cor(BGE$SigmaN)
BGE.test.param$cuts <- OSEM.test.param$cuts
BGE.test.param$data <- test.data
observedLL(BGE.test.param)
BGE <- scoreparameters("bge", train.data, bgepar = list(am = 0.05))
BGE.test.param <- BGE
BGE.test.param$Sigma_hat <- cov2cor(BGE$SigmaN)
BGE.test.param$cuts <- OSEM.test.param$cuts
BGE.test.param$data <- test.data
observedLL(BGE.test.param)
test <- sample(1:N, N/5, replace=FALSE)
train <- (-test)
train.data <- datRogers[train,]
test.data <- datRogers[test,]
# OSEM
OSEMfit <- ordinalStructEM(n, train.data,
usrpar = list(penType = "other",
L = 5,
lambda = 6))
OSEM.test.param <- OSEMfit$param
OSEM.test.param$data <- test.data
observedLL(OSEM.test.param)
# BGe
BGE <- scoreparameters("bge", train.data, bgepar = list(am = 0.05))
BGE.test.param <- BGE
BGE.test.param$Sigma_hat <- cov2cor(BGE$SigmaN)
BGE.test.param$cuts <- OSEM.test.param$cuts
BGE.test.param$data <- test.data
observedLL(BGE.test.param)
OSEMfit <- ordinalStructEM(n, train.data,
usrpar = list(penType = "other",
L = 5,
lambda = 4))
OSEM.test.param <- OSEMfit$param
OSEM.test.param$data <- test.data
observedLL(OSEM.test.param)
# BGe
BGE <- scoreparameters("bge", train.data, bgepar = list(am = 0.05))
BGE.test.param <- BGE
BGE.test.param$Sigma_hat <- cov2cor(BGE$SigmaN)
BGE.test.param$cuts <- OSEM.test.param$cuts
BGE.test.param$data <- test.data
observedLL(BGE.test.param)
OSEMfit <- ordinalStructEM(n, train.data,
usrpar = list(penType = "other",
L = 5,
lambda = 3))
OSEM.test.param <- OSEMfit$param
OSEM.test.param$data <- test.data
observedLL(OSEM.test.param)
BGE.test.param$muN
BGE.test.param$cuts <- OSEM.test.param$cuts - BGE.test.param$muN
BGE.test.param$cuts <- lapply(OSEM.test.param$cuts, function (cutvec) cutvec - BGE.test.param$muN)
BGE.test.param$cuts
BGE.test.param$cuts <- sapply(c(1:n), function(i) OSEM.test.param$cuts[[i]] - BGE.test.param$muN[i])
BGE.test.param$cuts
BGE.test.param$data <- test.data
observedLL(BGE.test.param)
BGE.test.param$cuts <- sapply(c(1:n), function(i) OSEM.test.param$cuts[[i]] + BGE.test.param$muN[i])
BGE.test.param$data <- test.data
observedLL(BGE.test.param)
OSEM.test.param$cuts[[24]]
BGE <- scoreparameters("bge", train.data, bgepar = list(am = 0.05))
BGE.test.param <- BGE
BGE.test.param$Sigma_hat <- cov2cor(BGE$SigmaN)
BGE.test.param$cuts <- sapply(c(1:n), function(i) OSEM.test.param$cuts[[i]] - BGE.test.param$muN[i])
BGE.test.param$data <- test.data
observedLL(BGE.test.param)
BGE.test.param$muN
BGE.test.param$cuts <- OSEM.test.param$cuts
#BGE.test.param$cuts <- sapply(c(1:n), function(i) OSEM.test.param$cuts[[i]] - BGE.test.param$muN[i])
BGE.test.param$data <- test.data
observedLL(BGE.test.param)
test <- sample(1:N, N/5, replace=FALSE)
train <- (-test)
train.data <- datRogers[train,]
test.data <- datRogers[test,]
# OSEM
OSEMfit <- ordinalStructEM(n, train.data,
usrpar = list(penType = "other",
L = 5,
lambda = 4))
OSEM.test.param <- OSEMfit$param
OSEM.test.param$data <- test.data
observedLL(OSEM.test.param)
# BGe
BGE <- scoreparameters("bge", train.data, bgepar = list(am = 0.05))
BGE.test.param <- BGE
BGE.test.param$Sigma_hat <- cov2cor(BGE$SigmaN)
BGE.test.param$cuts <- OSEM.test.param$cuts
#BGE.test.param$cuts <- sapply(c(1:n), function(i) OSEM.test.param$cuts[[i]] - BGE.test.param$muN[i])
BGE.test.param$data <- test.data
observedLL(BGE.test.param)
x <- c(rep(2,12), rep(2.5,3), rep(3,5),1)
?hist
hist(x,breaks = 10,xlim = c(1,5))
hist(x,breaks = 10,xlim = c(1,5),main = "Project difficulty",ylab= "Number of votes",xlab = "Difficulty")
abline(v = mean(x),col = "red")
text(2.5,8,paste("mean = ",mean(x)),col = "red")
x <- c(rep(2,12), rep(2.5,3), rep(3,5),1)
hist(x,breaks = 10,xlim = c(1,5),main = "Project difficulty",ylab= "Number of votes",xlab = "Difficulty")
abline(v = mean(x),col = "red")
text(2.5,8,paste("mean = ",round(mean(x),2)),col = "red")
x <- c(rep(2,12), rep(2.5,3), rep(3,5),1)
hist(x,breaks = 10,xlim = c(1,5),main = "Project difficulty",ylab= "Number of votes",xlab = "Difficulty")
abline(v = mean(x),col = "red")
text(3,8,paste("mean = ",round(mean(x),2)),col = "red")
x <- c(rep(2,12), rep(2.5,3), rep(3,5),1)
hist(x,breaks = 10,xlim = c(1,5),main = "Project difficulty",ylab= "Number of votes",xlab = "Difficulty")
abline(v = mean(x),col = "red")
text(2.8,8,paste("mean = ",round(mean(x),2)),col = "red")
getwd()
setwd("~/Documents/Projects/BiDAG/R")
insertSource("scoreagainstdag.R",package = "BiDAG")
# BDe
BDE <- scoreparameters("bdecat",datRogers,bdecatpar = list(chi = 1.5))
BDEfit <- iterativeMCMC(BDE)
scoreagainstDAG(BDE,BDEfit$DAG)
?scoreagainstDAG
scoreagainstDAG(BDE,BDEfit$DAG,test.data)
BDE <- scoreparameters("bdecat",datRogers,bdecatpar = list(chi = 1.5))
BDEfit <- iterativeMCMC(BDE)
scoreagainstDAG(BDE,BDEfit$DAG,test.data)
# BDe
BDE <- scoreparameters("bdecat",datRogers,bdecatpar = list(chi = 1))
BDEfit <- iterativeMCMC(BDE)
scoreagainstDAG(BDE,BDEfit$DAG,test.data)
# BDe
BDE <- scoreparameters("bdecat",datRogers,bdecatpar = list(chi = 2))
BDEfit <- iterativeMCMC(BDE)
scoreagainstDAG(BDE,BDEfit$DAG,test.data)
# BDe
BDE <- scoreparameters("bdecat",datRogers,bdecatpar = list(chi = 5))
BDEfit <- iterativeMCMC(BDE)
scoreagainstDAG(BDE,BDEfit$DAG,test.data)
# BDe
BDE <- scoreparameters("bdecat",datRogers,bdecatpar = list(chi = 10))
BDEfit <- iterativeMCMC(BDE)
scoreagainstDAG(BDE,BDEfit$DAG,test.data)
BDEfit$DAG
cpdag_BDe <- dag2cpdag(BDEfit$DAG)
plot(as(cpdag_OSEM, "graphNEL"),main = "OSEM")
plot(as(cpdag_BDe, "graphNEL"),main = "BDe")
# BDe
BDE <- scoreparameters("bdecat",datRogers,bdecatpar = list(chi = 20))
BDEfit <- iterativeMCMC(BDE)
scoreagainstDAG(BDE,BDEfit$DAG,test.data)
cpdag_BDe <- dag2cpdag(BDEfit$DAG)
dev.off()
plot(as(cpdag_BDe, "graphNEL"),main = "BDe")
# BDe
BDE <- scoreparameters("bdecat",datRogers,bdecatpar = list(chi = 0.01))
BDEfit <- iterativeMCMC(BDE)
scoreagainstDAG(BDE,BDEfit$DAG,test.data)
# BGe
BGE <- scoreparameters("bge", train.data, bgepar = list(am = 0.05))
BGEfit <- iterativeMCMC(BGE)
scoreagainstDAG(BGE,BGEfit$DAG,test.data)
scoreagainstDAG(BDE,BDEfit$DAG,test.data)
insertSource("scoreagainstdag.R",package = "BiDAG")
scoreagainstDAG(BGE,BGEfit$DAG,test.data)
sum(scoreagainstDAG(BGE,BGEfit$DAG,test.data))
observedLL(OSEM.test.param)
BDE <- scoreparameters("bdecat",datRogers,bdecatpar = list(chi = 1.5))
BDEfit <- iterativeMCMC(BDE)
scoreagainstDAG(BDE,BDEfit$DAG,test.data)
sum(scoreagainstDAG(BGE,BGEfit$DAG,test.data))
observedLL(BGE.test.param)
BDE
# Required packages
library(BiDAG)
setwd("~/Documents/Projects/OSEM/OSEM/R/")
# Major file containing the OSEM algorithm
source("ordinalScore.R")
# Modify some of the existing functions in the BiDAG package to accommodate our user-defined functions
insertSource("spacefns.R",package = "BiDAG")
insertSource("usrscorefns.R",package = "BiDAG")
setwd("~/Documents/Projects/BiDAG/R")
insertSource("scoreagainstdag.R",package = "BiDAG")
# Load data
load("OCDRogers.RData")
n <- ncol(datRogers)
setwd("~/Documents/Projects/OSEM/OSEM/pysch_application/")
load("OCDRogers.RData")
n <- ncol(datRogers)
N <- nrow(datRogers)
# Create training and test set for validation set approach (80% train/20% test)
test <- sample(1:N, N/5, replace=FALSE)
train <- (-test)
train.data <- datRogers[train,]
