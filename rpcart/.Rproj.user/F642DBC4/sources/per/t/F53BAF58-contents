obj_grad_helper <- function(n, N, trees, Theta, lambda_s) {
  tr_mat_vec <- list()
  comp_geno_vec <- list()
  node_labels_vec <- list()
  log_prob_vec <- c()

  for (i in c(1:N)) {
    tree <- trees[[i]]
    p <- build_poset(tree)
    comp_geno <- compatible_genotypes(p)
    comp_geno_vec <- append(comp_geno_vec, list(comp_geno))
    node_labels <- get_node_labels(p)
    node_labels_vec <- append(node_labels_vec, list(node_labels))
    tr_mat <- build_tr_mat(n, Theta, comp_geno, node_labels)
    tr_mat_vec <- append(tr_mat_vec, list(tr_mat))
    log_prob <- compute_obs_ll_(tr_mat, lambda_s)
    log_prob_vec <- c(log_prob_vec, log_prob)
  }

  res <- list("tr_mat_vec" = tr_mat_vec,
              "comp_geno_vec" = comp_geno_vec,
              "node_labels_vec" = node_labels_vec,
              "log_prob_vec" = log_prob_vec)
  return(res)
}


compatible_genotypes <- function(poset) {
  if (is.null(poset)) {
    return(matrix(0))
  } else {
    nr_nodes <- ncol(poset)
    genotypes <- matrix(rep(0, nr_nodes), ncol = nr_nodes)
    for (j in c(1:nr_nodes)) {
      temp <- genotypes
      pa_i <- which(poset[,j] == 1)
      if (length(pa_i) == 0) {
        for (k in c(1:nrow(temp))) {
          g <- matrix(temp[k,],ncol = nr_nodes)
          g[1,j] <- 1
          genotypes <- rbind(genotypes,g)
        }
      } else {
        for (k in c(1:nrow(temp))) {
          g <- matrix(temp[k,],ncol = nr_nodes)
          if (g[1,pa_i] == 1) {
            g[1,j] <- 1
            genotypes <- rbind(genotypes,g)
          }
        }
      }
    }
    if (nr_nodes > 1) {
      return(genotypes[order(apply(genotypes,1,sum)),])
    } else {
      return(genotypes)
    }
  }
}

get_node_labels <- function(poset) {
  if (is.null(poset)) {
    return(NULL)
  } else {
    mut <- as.integer(rownames(poset))
    nr_nodes <- nrow(poset)
    node_labels <- list()
    for (i in c(1:nr_nodes)) {
      label <- c(mut[i])
      j <- i
      repeat{
        pa_i <- which(poset[,j] == 1)
        if (length(pa_i) == 0) {
          break
        } else {
          label <- c(mut[pa_i], label)
          j <- pa_i
        }
      }
      node_labels <- c(node_labels, list(label))
    }
    return(node_labels)
  }
}

build_poset <- function(tree) {
  in_tree_idx <- which(tree$in_tree)[-1]
  nodes_in_tree <- tree$nodes[in_tree_idx]
  nr_nodes <- length(in_tree_idx)
  if (nr_nodes == 0) {
    return(NULL)
  } else {
    poset <- matrix(0, nrow = nr_nodes, ncol = nr_nodes)
    for (i in c(1:nr_nodes)) {
      pa_idx <- tree$parents[in_tree_idx[i]]
      if (pa_idx > 1) {
        pa_i <- which(in_tree_idx == pa_idx);
        poset[pa_i, i] <- 1
      }
    }
    dimnames(poset) <- list(c(nodes_in_tree),c(nodes_in_tree))
    if (nr_nodes > 1) {
      return(ggm::topSort(poset))
    } else {
      return(poset)
    }
  }
}

##' @export
compare_Theta <- function(true_Theta, pred_Theta) {

  MSE <- mean((true_Theta - pred_Theta)^2)
  n <- nrow(true_Theta)
  diag(true_Theta) <- 0
  diag(pred_Theta) <- 0
  q <- min(abs(true_Theta[true_Theta != 0])) * 0.5
  pred_Theta[pred_Theta > q] <- 1
  pred_Theta[pred_Theta < -q] <- -1
  pred_Theta[(pred_Theta <= q) & (pred_Theta >= -q)] <- 0
  # pred_Theta[pred_Theta > 0] <- 1
  # pred_Theta[pred_Theta < 0] <- -1
  true_Theta[true_Theta > 0] <- 1
  true_Theta[true_Theta < 0] <- -1

  # Number of edges in the estimated Theta
  pred_P <- sum(pred_Theta != 0)

  # Number of edges in the true Theta
  true_P <- sum(true_Theta != 0)

  # Number of non-edges in the true Theta
  true_N <- sum(true_Theta == 0) - n

  # TP, FP, TN, FN, SHD
  TP <- sum((pred_Theta != 0) * (pred_Theta == true_Theta))
  FP <- pred_P - TP
  FN <- sum((pred_Theta == 0) * (true_Theta != 0))
  TN <- sum((pred_Theta == 0) * (true_Theta == 0)) - n
  SHD <- FP + FN

  # Precision
  if ((TP + FP) == 0) {
    Precision <- 0
  } else {
    Precision <- TP / (TP + FP)
  }

  # TPR, FPR_P, FPR_N
  if (true_P == 0) { # true graph is empty
    if (FP >= 0) {
      TPR <- 0
      FPR_P <- 1
    } else {
      TPR <- 1
      FPR_P <- 0
    }
  } else { # true graph is non-empty
    TPR <- TP / true_P
    FPR_P <- FP / true_P
  }

  if (true_N == 0) { # true graph is full
    FPR_N <- 0
  } else { # true graph is not full
    FPR_N <- FP / true_N
  }


  compTheta <- c(SHD,TP,FP,TN,FN,Precision,TPR,FPR_N,FPR_P,MSE)
  names(compTheta) <- c("SHD","TP","FP","TN","FN","Precision","TPR","FPR_N","FPR_P","MSE")
  return(round(compTheta,2))

}


check_mutations <- function(n, trees) {
  all_muts <- c(1:n)
  for (tree in trees) {
    all_muts <- setdiff(all_muts, tree$nodes[tree$in_tree])
    if (length(all_muts) == 0) {
      return(TRUE)
    }
  }
  return(FALSE)
}

remove_empty_trees <- function(trees) {
  temp <- list()
  for (i in c(1:length(trees))) {
    tree <- trees[[i]]
    if (sum(tree$in_tree) != 1) {
      temp <- append(temp, list(tree))
    }
  }
  return(temp)
}

remove_super_trees <- function(trees, n) {

  temp <- list()

  if (n <= 10) {
    cutoff <- min(floor(quantile(sapply(trees, function(tree) sum(tree$in_tree)), 0.9)), n + 1)
  } else {
    cutoff <- min(floor(quantile(sapply(trees, function(tree) sum(tree$in_tree)), 0.9)), round(n / 2)  + 1)
  }

  # cutoff <- min(floor(quantile(sapply(trees, function(tree) sum(tree$in_tree)), 0.9)), round(n / 2)  + 1)

  for (i in c(1:length(trees))) {
    tree <- trees[[i]]
    if (sum(tree$in_tree) < cutoff) {
      temp <- append(temp, list(tree))
    }
  }

  temp2 <- list()
  cutoff <- 1000
  for (i in c(1:length(temp))) {
    tree <- temp[[i]]
    p <- build_poset(tree)
    comp_geno <- compatible_genotypes(p)
    if (nrow(comp_geno) < cutoff) {
      temp2 <- append(temp2, list(tree))
    }
  }

  return(temp2)
}

##' @export
plot_tree <- function(tree, mutations) {

  nodes <- c("Root", mutations[tree$nodes[tree$in_tree]])
  parents <- tree$parents[tree$in_tree]
  idx <- which(tree$in_tree)
  p <- length(nodes)
  nodes <- sapply(c(1:p), function (i) paste(nodes[i],idx[i]))

  AM <- matrix(0, nrow = p, ncol = p)
  for (i in c(2:p)) {
    pa <- tree$nodes[parents[i]]
    if (parents[i] == 1) {
      pa_idx <- 1
    } else {
      pa_idx <- which(nodes == paste(mutations[pa],parents[i]))
    }
    AM[i, pa_idx] <- 1

  }
  rownames(AM) <- nodes
  colnames(AM) <- nodes
  try(dev.off(),silent = TRUE)
  if (is.null(tree$label)) {
    Rgraphviz::plot(graph::graphAM(t(AM), "directed"), main = "tree")
  } else {
    Rgraphviz::plot(graph::graphAM(t(AM), "directed"), main = tree$label)
  }
}


