getwd()
library(BiDAG)
library(Rgraphviz)
library(pcalg)
library(graph)
library(MXM)
source("ordinalScore.R") 
# Modify some of the existing functions in the BiDAG package to accommodate our user-defined functions
insertSource("spacefns.R",package = "BiDAG")
install.packages("leaps")
source("ordinalScore.R") 
# Modify some of the existing functions in the BiDAG package to accommodate our user-defined functions
insertSource("spacefns.R",package = "BiDAG")
install.packages("glmnet")
source("ordinalScore.R") 
source("ordinalScore.R") 
# Modify some of the existing functions in the BiDAG package to accommodate our user-defined functions
insertSource("spacefns.R",package = "BiDAG")
insertSource("usrscorefns.R",package = "BiDAG")
rmvDAG2 <- function(N, randDAGobj) {
  AM <- as(randDAGobj, "matrix")
  sorted_ind <- ggm::topOrder((AM != 0))
  n <- nrow(AM)
  data <- matrix(nrow = N,ncol = n)
  for (j in sorted_ind) {
    parentnodes <- which(AM[,j] != 0)
    lp <- length(parentnodes)
    switch (as.character(lp),
            "0" = {data[,j] <- rnorm(N)},
            "1" = {data[,j] <- rnorm(N, mean = data[,parentnodes] * AM[parentnodes,j], sd = 1)},
            {data[,j] <- rnorm(N, mean = data[,parentnodes] %*% AM[parentnodes,j], sd = 1)}
    )
  }
  return(data)
}
cutfun <- function(L,c) {
  p <- gtools::rdirichlet(1,rep(c,L))
  return(qnorm(cumsum(p)[1:(L-1)]))
}
convertToOrdinal <- function(scaled_data, exp_levels = 4,concent_param = 2) {
  n <- ncol(scaled_data)
  if (exp_levels == 2) {
    ordinal_levels <- replicate(n,2)
  } else {
    ordinal_levels <- replicate(n,sample(c(2:(2 * exp_levels - 2)),1))
  }
  ordinal_data <- scaled_data
  for (i in c(1:n)) {
    
    check_levels <- ordinal_levels[i] - 1
    while (check_levels != ordinal_levels[i]) {
      cuts <- c(-Inf, 
                cutfun(ordinal_levels[i],concent_param), 
                Inf)
      temp <- cut(scaled_data[,i], simplify2array(cuts), labels = FALSE) - 1
      check_levels <- length(unique(temp))
    }
    ordinal_data[,i] <- temp
    
  }
  colnames(ordinal_data) <- c(1:n)
  return(ordinal_data)
}
catCItest <- function(x, y, S, suffStat) {
  d <- as.data.frame(suffStat$data)
  d[] <- lapply(d[], as.ordered)
  return(gRim::ciTest_ordinal(d,
                              set = as.numeric(c(x,y,S)),
                              statistic = suffStat$stat_type)$P)
}
mywFUN <- function(m) {
  return(replicate(m,mywFUNhelper()))
}
mywFUNhelper <- function() {
  y <- runif(1, 0, 1.2)
  if( y < 0.6 ){
    x <- -1 + y
  }else{
    x <- 0.4 + y - 0.6
  }
  return(x)
}
set.seed(888)
# Generate a regular DAG with 20 nodes with 4 number of neighbors
n <- 20
trueDAG <- randDAG(n = n, d = 4, method = "power", wFUN = list(mywFUN))
# Generate a Gaussian dataset based on the DAG and standardize each dimension
# Sample size = 500
N <- 500
hidden_data <- rmvDAG2(N, trueDAG)
truecov <- trueCov(trueDAG)
D <- diag(sqrt(diag(truecov)))
D.inv <- chol2inv(chol(D))
trueSigma <- D.inv %*% truecov %*% D.inv
scaled_data <- t(D.inv %*% t(hidden_data))
# Convert the Gaussian dataset into an ordinal dataset
ordinal_data <- convertToOrdinal(scaled_data, exp_levels = 4,concent_param = 2)
install.packages("gtools")
ordinal_data <- convertToOrdinal(scaled_data, exp_levels = 4,concent_param = 2)
NPCfit <- pc(suffStat = list(data = ordinal_data, stat_type = "dev"),
             alpha = 0.05,
             indepTest = catCItest,
             labels = colnames(ordinal_data))
install.packages("gRim")
NPCfit <- pc(suffStat = list(data = ordinal_data, stat_type = "dev"),
             alpha = 0.05,
             indepTest = catCItest,
             labels = colnames(ordinal_data))
comparePatterns(NPCfit,trueDAG) # hard version
comparePatterns(NPCfit,trueDAG,hardP2P = FALSE) # soft version
OPCfit <- pc(suffStat = list(data = ordinal_data, stat_type = "jt"),
             alpha = 0.05,
             indepTest = catCItest,
             labels = colnames(ordinal_data))
comparePatterns(OPCfit,trueDAG) # hard version
comparePatterns(OPCfit,trueDAG,hardP2P = FALSE) #soft version
GPCfit <- pc(suffStat = list(C = cor(ordinal_data), n = N),
             alpha = 0.05,
             indepTest = gaussCItest,
             labels = colnames(ordinal_data))
comparePatterns(GPCfit,trueDAG) # hard version
comparePatterns(GPCfit,trueDAG,hardP2P = FALSE) # soft version
BDE <- scoreparameters("bdecat",data.frame(ordinal_data),bdecatpar = list(chi = 0.5))
BDEfit <- iterativeMCMC(BDE)
comparePatterns(BDEfit$DAG,trueDAG) # hard version
comparePatterns(BDEfit$DAG,trueDAG,hardP2P = FALSE) # soft version
BGE <- scoreparameters("bge", ordinal_data, bgepar = list(am = 0.5))
BGEfit <- iterativeMCMC(BGE,scoreout = TRUE)
comparePatterns(BGEfit$DAG,trueDAG) # hard version
comparePatterns(BGEfit$DAG,trueDAG,hardP2P = FALSE) # soft version
OSEMfit <- ordinalStructEM(n, ordinal_data,
                           usrpar = list(penType = "other",
                                         L = 5,
                                         lambda = 2))
install.packages("mvtnorm")
OSEMfit <- ordinalStructEM(n, ordinal_data,
                           usrpar = list(penType = "other",
                                         L = 5,
                                         lambda = 2))
install.packages("psych")
OSEMfit <- ordinalStructEM(n, ordinal_data,
                           usrpar = list(penType = "other",
                                         L = 5,
                                         lambda = 2))
install.packages("tmvmixnorm")
OSEMfit <- ordinalStructEM(n, ordinal_data,
                           usrpar = list(penType = "other",
                                         L = 5,
                                         lambda = 2))
comparePatterns(OSEMfit$DAG,trueDAG) # hard version
comparePatterns(OSEMfit$DAG,trueDAG,hardP2P = FALSE) # soft version
d <- as.data.frame(ordinal_data)
d[] <- lapply(d[], as.ordered)
skel <- pc.skel(d, method = "comb.mm", alpha = 0.05)
MMDAG <- pc.or(skel)$G
MMDAG[MMDAG == 2] <- 1
MMDAG[MMDAG == 3] <- 0
comparePatterns(MMDAG,trueDAG) # hard version
comparePatterns(MMDAG,trueDAG,hardP2P = FALSE) # soft version
skel <- pc.skel(d, method = "comb.mm", alpha = 0.1)
comparePatterns(MMDAG,trueDAG,hardP2P = FALSE) # soft version
MMDAG <- pc.or(skel)$G
MMDAG[MMDAG == 2] <- 1
MMDAG[MMDAG == 3] <- 0
comparePatterns(MMDAG,trueDAG,hardP2P = FALSE) # soft version
skel <- pc.skel(d, method = "comb.mm", alpha = 0.15)
MMDAG <- pc.or(skel)$G
MMDAG[MMDAG == 2] <- 1
MMDAG[MMDAG == 3] <- 0
comparePatterns(MMDAG,trueDAG) # hard version
comparePatterns(MMDAG,trueDAG,hardP2P = FALSE) # soft version
skel <- pc.skel(d, method = "comb.mm", alpha = 0.2)
comparePatterns(MMDAG,trueDAG) # hard version
MMDAG <- pc.or(skel)$G
MMDAG[MMDAG == 2] <- 1
MMDAG[MMDAG == 3] <- 0
comparePatterns(MMDAG,trueDAG) # hard version
comparePatterns(MMDAG,trueDAG,hardP2P = FALSE) # soft version
install.packages("rmarkdown")
library(rpcart)
library(rpcart)
q()
